# 🤖 AI 自我进化日志 (.ai-errors-log.md)

> 此文件是 AI 的外部长期记忆。
> **指令**：每次开始新任务前，AI 必须读取此文件，检查是否有相关的历史错误模式，避免重蹈覆辙。

## 🧠 错误模式库 (Pattern Library)
此处记录高频错误模式，AI 编码前需强制检索。

### 通用模式

- **PATTERN-001**: 路径拼接错误（跨平台兼容性）
  - **特征**: 使用 `+ '\\'` 或 `+ '/'` 拼接路径
  - **修正**: 必须使用 `os.path.join(base, sub, file)`
  - **规则**: `.cursorrules/路径处理`
  - **示例**:
    ```python
    # ❌ 错误
    path = base_dir + '\\' + filename
    # ✅ 正确
    path = os.path.join(base_dir, filename)
    ```

- **PATTERN-002**: 类型提示过度复杂
  - **特征**: 使用 `Optional[str] = None` 等复杂类型提示
  - **修正**: 遵循 liuns 风格，简化为 `str = None`
  - **规则**: `.cursorrules/代码风格 - 简洁、优化、易读`
  - **示例**:
    ```python
    # ❌ 过度复杂
    from typing import Optional
    def func(file: Optional[str] = None) -> str:
    # ✅ 简洁
    def func(file: str = None) -> str:
    ```


---

## 📜 详细错误流水 (Event Log)

### [2026-01-07] 简化类型提示，代码更简洁
- **Context**: `cedar/utils/s_print.py` 第 50 行函数参数类型提示
- **Pattern**: PATTERN-002
- **Error**: 使用 `Optional[str] = None` 过度复杂
- **Root Cause**: 不符合 liuns 风格（简洁、优化、易读）
- **Fix**: 简化为 `str = None`，移除 `Optional` 导入
- **Impact**: 代码更简洁易读，符合项目代码规范
- **Code**:
  ```python
  # 修改前
  from typing import Any, Optional
  def print(*args: Any, sep: str = ' ', end: str = '\n', file: Optional[str] = None) -> str:
  
  # 修改后
  from typing import Any
  def print(*args: Any, sep: str = ' ', end: str = '\n', file: str = None) -> str:
  ```
- **知识点**: Python 类型提示简化，遵循项目代码风格规范

### [2026-01-08] macOS 通知不可靠，改用弹窗对话框
- **Context**: `src/status_bar.py` 第 370 行 `showAbout_` 方法
- **Pattern**: PATTERN-003 (新增)
- **Error**: 使用 `NSUserNotificationCenter` 发送通知，用户点击后无反应
- **Root Cause**: macOS 通知中心可能被禁用、静默或需要权限
- **Fix**: 改用 `NSAlert` 弹窗对话框，更可靠且信息更丰富
- **Impact**: 用户体验提升，确保信息展示
- **Code**:
  ```python
  # 修改前 (不可靠)
  def showAbout_(self, sender):
      self.send_notification("CommondX", "Mac 文件剪切移动工具")
  
  # 修改后 (可靠)
  def showAbout_(self, sender):
      from AppKit import NSAlert, NSApp
      alert = NSAlert.alloc().init()
      alert.setMessageText_("CommondX")
      alert.setInformativeText_("详细信息...")
      alert.addButtonWithTitle_("确定")
      NSApp.activateIgnoringOtherApps_(True)
      alert.runModal()
  ```
- **知识点**: macOS 开发中，重要信息展示优先使用 `NSAlert`，通知仅用于后台提醒

### 通用模式 (新增)

- **PATTERN-003**: macOS 通知不可靠
  - **特征**: 使用 `NSUserNotificationCenter` 展示重要信息
  - **修正**: 重要信息用 `NSAlert` 弹窗，通知仅用于后台提醒
  - **规则**: 用户交互可靠性优先

- **PATTERN-004**: PyInstaller 打包后路径问题
  - **特征**: 使用 `__file__` 定位配置文件
  - **修正**: 打包后 bundle 内文件只读，用户数据需存到 `~/Library/Application Support/`
  - **规则**: 静态配置写代码里，动态数据存用户目录

- **PATTERN-005**: Finder 目标文件夹检测不准
  - **特征**: 使用 `target of front window` 获取目标路径
  - **修正**: 使用 `insertion location` 获取准确的插入位置
  - **规则**: AppleScript 优先使用原生属性

- **PATTERN-006**: macOS 辅助功能权限基于路径
  - **特征**: 每次打包后需重新授权
  - **修正**: 打包脚本添加 `tccutil reset Accessibility` 清除旧记录
  - **规则**: 开发时自动清理授权缓存

---

### [2026-01-08] 许可证管理简化
- **Context**: `src/license_manager.py` 配置存储
- **Pattern**: PATTERN-004
- **Error**: 配置文件在打包后无法写入（bundle 只读）
- **Fix**: 静态配置（trial_days）写代码里，用户数据存 `~/Library/Application Support/CommondX/user.yaml`
- **Impact**: 打包后激活功能正常工作

### [2026-01-08] 权限管理模块化
- **Context**: 辅助功能权限分散在多个文件
- **Fix**: 创建 `src/permission.py` 统一管理
  - `check_accessibility()` - 检查权限
  - `request_accessibility()` - 请求权限
  - `open_accessibility_settings()` - 打开系统设置
- **Impact**: 代码更清晰，状态栏菜单支持手动检查权限

### [2026-01-08] 桌面文件移动修复
- **Context**: `src/cut_manager.py` 获取目标文件夹
- **Pattern**: PATTERN-005
- **Error**: 使用 `target of front window` 无法准确检测桌面
- **Fix**: 改用 `insertion location` 获取 Finder 当前插入位置
- **Code**:
  ```applescript
  -- 修改前
  return POSIX path of (target of front window as alias)
  
  -- 修改后
  set insertLoc to insertion location as alias
  return POSIX path of insertLoc
  ```
- **Impact**: 文件可正确移动到桌面

### [2026-01-08] 打包脚本优化
- **Context**: `tools/build_dmg.sh`
- **Pattern**: PATTERN-006
- **Fix**: 打包前自动清除辅助功能授权记录
- **Code**:
  ```bash
  tccutil reset Accessibility com.liuns.commondx 2>/dev/null || true
  ```
- **Impact**: 避免每次打包后手动清理授权

---

### [2026-01-08] 全局代码优化 - liuns 风格重构

本次对整个项目进行了系统性优化，遵循 liuns 风格（简洁、优化、易读）。

#### 优化统计
| 文件 | 优化前 | 优化后 | 减少 |
|------|--------|--------|------|
| `main.py` | 51 行 | 26 行 | 49% |
| `src/app.py` | 149 行 | 105 行 | 30% |
| `src/cut_manager.py` | 175 行 | 110 行 | 37% |
| `src/event_tap.py` | 125 行 | 80 行 | 36% |
| `src/launch_agent.py` | 101 行 | 66 行 | 35% |
| `src/license_manager.py` | 114 行 | 88 行 | 23% |
| `src/permission.py` | 31 行 | 24 行 | 23% |
| `src/status_bar.py` | 495 行 | 270 行 | 45% |

#### 优化模式总结

- **PATTERN-007**: 提取公共辅助函数
  - **特征**: 重复的代码块（如 subprocess 调用、菜单项创建）
  - **修正**: 提取为私有辅助函数 `_xxx()`
  - **示例**: `_run_script()`, `_item()`, `_show_alert()`

- **PATTERN-008**: 使用 pathlib 替代 os.path
  - **特征**: `os.path.join()`, `os.path.exists()` 等
  - **修正**: 使用 `Path` 对象，更简洁现代
  - **示例**: `Path.home() / "Library/..."`

- **PATTERN-009**: 删除调试日志
  - **特征**: `print(f"[DEBUG] ...")` 或 `[TAG] ` 前缀日志
  - **修正**: 生产代码删除调试日志，保留关键操作日志

- **PATTERN-010**: 简化条件逻辑
  - **特征**: 深层嵌套的 if-else、重复的条件检查
  - **修正**: 提前返回、字典映射、三元表达式

- **PATTERN-011**: PyObjC NSObject 子类方法命名冲突
  - **特征**: NSObject 子类中的 `_xxx` 方法被误认为 ObjC 属性访问器
  - **修正**: 辅助方法提取到类外部作为普通函数
  - **示例**: `_item` → 类外 `_add_menu_item()`

- **PATTERN-012**: AppleScript 格式敏感
  - **特征**: 简化 AppleScript 后返回空结果
  - **原因**: AppleScript 对格式、换行、变量赋值方式敏感
  - **修正**: 保持原始格式，不要过度简化
  - **示例**:
    ```applescript
    # ❌ 错误 - 直接在 repeat 中使用 selection
    tell application "Finder"
        repeat with f in selection
            ...
        end repeat
    end tell
    
    # ✅ 正确 - 先赋值再遍历
    tell application "Finder"
        set selectedItems to selection
        repeat with itemRef in selectedItems
            ...
        end repeat
    end tell
    ```
  - **关键**: 三引号 `'''` 后要有换行，先 `set` 赋值再 `repeat` 遍历

#### 具体优化点

1. **删除未用导入**: `sys`, `os`, `threading`, `NSFont`, `Tuple` 等
2. **合并初始化**: `self.a = self.b = self.c = None`
3. **统一用 pathlib**: `Path()` 替代 `os.path`
4. **提取公共函数**:
   - `cut_manager.py`: `_run_script()`, `_escape()`
   - `status_bar.py`: `_item()`, `_draw_blade()`, `_show_alert()`, `_copy_to_clipboard()`
5. **简化函数名**: `_notify_state_change` → `_notify`, `verify_activation_code` → `verify`
6. **合并重复代码**: `setup_menu()` 中 trial/expired 状态合并
7. **使用字典映射**: `_start_event_tap()` 中用字典替代 if-elif-else
8. **常量提升**: `FINDER_ID`, `DAY_SECS`, `ACCESSIBILITY_URL` 等

#### 配置变更
- **试用时间**: 3 天 → 21 天 (`TRIAL_DAYS = 21`)

---

### [2026-01-08] putText 函数返回值未接收
- **Context**: `tools/generate_dmg_background.py` 第 22 行文字绘制
- **Pattern**: PATTERN-013 (新增)
- **Error**: 简化代码时错误移除了 `putText` 的返回值赋值，导致文字未绘制
- **Root Cause**: `putText` 函数返回修改后的图像，而不是直接修改原图像（类似 PIL 的 `ImageDraw`）
- **Fix**: 必须接收返回值 `bg = putText(bg, ...)`
- **Impact**: 文字绘制功能失效
- **Code**:
  ```python
  # ❌ 错误 - 未接收返回值
  putText(bg, "拖拽到 Applications 文件夹安装", (200, h-100), (10, 10, 10), 18)
  
  # ✅ 正确 - 接收返回值
  bg = putText(bg, "拖拽到 Applications 文件夹安装", (200, h-100), (10, 10, 10), 18)
  ```
- **知识点**: 图像处理函数需要区分是原地修改（如 OpenCV 的 `cv2.line`）还是返回新图像（如 `putText`），简化代码时不能随意移除返回值赋值

### 通用模式 (新增)

- **PATTERN-013**: 图像处理函数返回值未接收
  - **特征**: 调用返回新图像的函数时未接收返回值
  - **修正**: 必须接收返回值 `img = func(img, ...)`
  - **规则**: 区分原地修改和返回新图像的函数，简化代码时不能移除返回值赋值

- **PATTERN-014**: 重构时意外删除导入语句
  - **特征**: 重构代码时删除或遗漏了必要的 import 语句
  - **修正**: 重构后必须验证所有导入语句完整，特别是替换文件头部时
  - **规则**: 重构时保留所有导入语句，或使用工具自动检查导入完整性

- **PATTERN-015**: 弹窗取消操作后错误重置状态
  - **特征**: 用户选择"取消"后，错误地重置了状态跟踪变量（如 last_selection）
  - **修正**: 取消操作应该保持状态不变，只有执行操作后才重置状态
  - **规则**: 区分"取消"和"执行操作"两种场景，取消时保持状态以便用户重试

- **PATTERN-016**: macOS Event Tap 在模态对话框期间被系统禁用
  - **特征**: 显示模态对话框（NSAlert.runModal）后，Event Tap 停止工作，后续键盘事件无法捕获
  - **原因**: macOS 在显示模态对话框时可能会自动禁用 Event Tap，这是系统安全机制
  - **修正**: 
    1. 弹窗显示时不激活应用（不调用 `activateIgnoringOtherApps`），保持 Finder 为活动窗口
    2. 弹窗关闭后立即尝试重新启用 Event Tap
    3. 使用多次延迟恢复（50ms、100ms、200ms），确保系统完全退出模态状态
    4. 在 Event Tap 回调开始时也确保启用状态，自动恢复被禁用的 Event Tap
    5. 如果重新启用失败，完全重新创建 Event Tap
  - **规则**: 
    - 模态对话框显示时不要激活应用，避免影响 Event Tap
    - 弹窗关闭后必须恢复 Event Tap，使用多次延迟确保成功
    - Event Tap 回调中也要检查并恢复状态
  - **代码示例**:
    ```python
    # ✅ 正确 - 不激活应用
    original_policy = NSApp.activationPolicy()
    if original_policy == 2:
        NSApp.setActivationPolicy_(0)
    # 不调用 activateIgnoringOtherApps
    
    # 弹窗关闭后多次延迟恢复
    self._restoreEventTap_(None)  # 立即
    for delay in [0.05, 0.1, 0.2]:  # 延迟恢复
        NSTimer.scheduledTimerWithTimeInterval_target_selector_userInfo_repeats_(
            delay, self, "_restoreEventTap:", None, False
        )
    
    # Event Tap 回调中自动恢复
    def _callback(self, proxy, event_type, event, refcon):
        if self.running and self.tap:
            CGEventTapEnable(self.tap, True)  # 确保启用
        # ... 处理事件
    ```
  - **知识点**: macOS Event Tap 是系统级事件拦截机制，模态对话框会暂停它，需要主动恢复

---

### [2026-01-10] macOS Event Tap 在模态对话框后失效 - 彻底修复经验总结

#### 问题描述
弹窗显示后，Event Tap 停止工作，后续 Cmd+X 事件无法被捕获，连日志都没有。

#### 问题分析过程

**假设 A**: Finder 未恢复为活动窗口
- **验证**: 日志显示 Finder 已恢复（行 77, 84）
- **结论**: 被拒绝

**假设 B**: Finder 检查失败
- **验证**: 日志显示没有第三次 Cmd+X 的任何记录
- **结论**: Event Tap 根本没有被调用，不是 Finder 检查问题

**假设 C**: Event Tap 被系统禁用
- **验证**: 日志显示最后一次 Event Tap 调用在弹窗关闭后，之后没有任何调用
- **结论**: 确认 - Event Tap 在模态对话框期间被系统禁用

**假设 D**: Event Tap 回调未被触发
- **验证**: 添加了回调入口日志，确认回调没有被调用
- **结论**: 确认 - Event Tap 被系统暂停，回调不再被触发

#### 修复方案（五层防护机制）

**第一层：不激活应用**
```python
# file_dialog.py
original_policy = NSApp.activationPolicy()
if original_policy == 2:
    NSApp.setActivationPolicy_(0)
# 不调用 activateIgnoringOtherApps，保持 Finder 为活动窗口
```

**第二层：弹窗关闭后立即恢复**
```python
# app.py
if self.event_tap:
    self.event_tap.ensure_enabled()
```

**第三层：多次延迟恢复**
```python
# app.py
self._restoreEventTap_(None)  # 立即
for delay in [0.05, 0.1, 0.2]:  # 延迟恢复
    NSTimer.scheduledTimerWithTimeInterval_target_selector_userInfo_repeats_(
        delay, self, "_restoreEventTap:", None, False
    )
```

**第四层：回调中自动恢复**
```python
# event_tap.py
def _callback(self, proxy, event_type, event, refcon):
    if self.running and self.tap:
        CGEventTapEnable(self.tap, True)  # 确保启用
    # ... 处理事件
```

**第五层：完全重新创建**
```python
# event_tap.py
def ensure_enabled(self):
    try:
        CGEventTapEnable(self.tap, True)
        return True
    except:
        return self._recreate_tap()  # 失败则重新创建
```

#### 关键经验总结

1. **macOS Event Tap 与模态对话框冲突**
   - 模态对话框（`NSAlert.runModal()`）会暂停 Event Tap
   - 这是 macOS 的安全机制，必须主动恢复
   - 不能依赖系统自动恢复

2. **不要激活应用**
   - 弹窗显示时激活应用会导致 Finder 不再是活动窗口
   - Event Tap 检查 `_is_finder_active()` 会失败
   - 只改变激活策略，不强制激活应用

3. **延迟恢复的重要性**
   - 系统退出模态状态需要时间
   - 立即恢复可能失败，因为系统还没有完全退出模态状态
   - 使用多次延迟恢复（50ms、100ms、200ms）确保成功

4. **多层防护机制**
   - 单一修复方案可能不够
   - 使用多层防护，确保 Event Tap 能够恢复
   - 即使某一层失败，其他层也能恢复

5. **自动恢复机制**
   - 在回调中自动恢复，即使被系统禁用也能自动恢复
   - 这样即使弹窗关闭后恢复失败，下次事件时也能自动恢复

6. **完全重新创建**
   - 如果重新启用失败，完全重新创建 Event Tap
   - 确保 Event Tap 能够正常工作

#### 调试技巧

1. **添加详细日志**
   - 记录 Event Tap 的每次调用
   - 记录 Finder 检查结果
   - 记录恢复过程

2. **使用调试日志文件**
   - 将关键信息写入调试日志（`.cursor/debug.log`）
   - 使用 NDJSON 格式，便于分析
   - 记录假设验证过程

3. **多次尝试**
   - 使用定时器多次尝试恢复
   - 确保系统完全退出模态状态后再恢复

4. **验证状态**
   - 恢复后验证 Event Tap 是否真的工作
   - 检查日志确认后续事件是否被捕获

#### 修复提示词模板

当遇到 macOS Event Tap 相关问题时的检查清单：

1. **弹窗显示时是否激活了应用？**
   - ❌ 如果调用了 `activateIgnoringOtherApps`，移除它
   - ✅ 只改变激活策略，不强制激活

2. **弹窗关闭后是否恢复了 Event Tap？**
   - ❌ 如果没有，添加立即恢复
   - ✅ 添加多次延迟恢复（50ms、100ms、200ms）

3. **Event Tap 回调中是否检查状态？**
   - ❌ 如果没有，在回调开始时确保启用
   - ✅ 每次回调都确保 Event Tap 已启用

4. **恢复失败时是否重新创建？**
   - ❌ 如果只是重新启用，添加重新创建机制
   - ✅ 如果重新启用失败，完全重新创建 Event Tap

5. **是否添加了详细日志？**
   - ❌ 如果没有，添加日志记录恢复过程
   - ✅ 记录每次恢复尝试的结果

#### 相关模式
- PATTERN-016: macOS Event Tap 在模态对话框期间被系统禁用
- PATTERN-015: 弹窗取消操作后错误重置状态
- PATTERN-014: 重构时意外删除导入语句